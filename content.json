{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"near2sea","url":"https://near2sea.github.io"},"pages":[],"posts":[{"title":"ios搭建项目脚手架","slug":"ios搭建项目脚手架","date":"2019-01-09T02:32:20.000Z","updated":"2019-01-09T02:40:22.818Z","comments":true,"path":"2019/01/09/ios搭建项目脚手架/","link":"","permalink":"https://near2sea.github.io/2019/01/09/ios搭建项目脚手架/","excerpt":"","text":"使用carthage安装1234567brew updatebrew install carthage# 项目根目录下touch Cartfile# 下载源码生成frameworkcarthage updatecarthage update --platform ios 配置 打开 Build Phases 选项卡. 点击 + 添加，选择 New Run Script 1/usr/local/bin/carthage copy-frameworks 在input Files项添加 1$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework 在Output Files项添加 1$(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/Alamofire.framework Cartfile配置1234567891011121314151617181920212223242526272829303132333435github &quot;near2sea/Mantle&quot; &quot;feature/near2sea&quot; #扩展Mantle代替github &quot;Mantle/Mantle&quot;github &quot;near2sea/YTKNetwork&quot; &quot;feature/near2sea&quot; #优化项目代替github &quot;yuantiku/YTKNetwork&quot; ~&gt; 2.0github &quot;near2sea/XLForm&quot; &quot;feature/datasource&quot; #扩展xlform代替github &quot;xmartlabs/XLForm&quot; ~&gt; 4.0github &quot;jdg/MBProgressHUD&quot; ~&gt; 1.1.0github &quot;SVProgressHUD/SVProgressHUD&quot;github &quot;ibireme/YYCache&quot;github &quot;ibireme/YYCategories&quot;github &quot;layoutBox/FlexLayout&quot; #把yoga打包成framework,build Settings选项卡Always Embed Swift Standard Libraries属性设置为YESgithub &quot;airbnb/lottie-ios&quot; &quot;master&quot;## 可选github &quot;WenchaoD/FSCalendar&quot;github &quot;hackiftekhar/IQKeyboardManager&quot;github &quot;Ramotion/circle-menu&quot;github &quot;MortimerGoro/MGSwipeTableCell&quot; #cell左右滑动github &quot;chiahsien/CHTCollectionViewWaterfallLayout&quot; #类似瀑布流github &quot;realm/realm-cocoa&quot;## swiftgithub &quot;ReactiveX/RxSwift&quot; ~&gt; 4.0github &quot;Alamofire/Alamofire&quot; &quot;5.0.0.beta.1&quot; 使用pod1pod &apos;YogaKit&apos;, &apos;~&gt; 1.7&apos; #需加入libc++.tbd,已加FlexLayout则不需要","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/tags/ios/"}],"keywords":[]},{"title":"xcode通用代码片段","slug":"xcode通用代码片段","date":"2019-01-07T06:29:49.000Z","updated":"2019-01-07T06:42:01.178Z","comments":true,"path":"2019/01/07/xcode通用代码片段/","link":"","permalink":"https://near2sea.github.io/2019/01/07/xcode通用代码片段/","excerpt":"","text":"用于xcode使用的ios通用代码片段 https://github.com/QMUI/QMUI_iOS_CodeSnippets 使用方式Xcode 的 Code Snippets 文件存放于 ~/Library/Developer/Xcode/UserData/CodeSnippets 目录，只要直接把 *.codesnippets 文件放到这个目录下（若没有则自己创建），重启 Xcode 即可生效。 12cd ~/Library/Developer/Xcode/UserData/CodeSnippetsgit clone https://github.com/QMUI/QMUI_iOS_CodeSnippets.git ./ 快捷键汇总 propertySwizzleWeak - 用 swizzle 的方式定义一个 weak 的property sharedInstance - 为当前类创建一个实现单例功能的 sharedInstance 方法 block* - block相关 pragma - 展开一个用于 Xcode 导航的 #pragma mark - 宏 __weakSelf - 定义一个 weak 的 self 指针 timeConsuming - 展开一段用 CACurrentMediaTime() 来计算方法耗时的代码","categories":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/tags/ios/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}]},{"title":"ios小结presentViewController延迟问题","slug":"ios小结presentViewController延迟问题","date":"2019-01-05T09:17:23.000Z","updated":"2019-01-05T09:23:08.546Z","comments":true,"path":"2019/01/05/ios小结presentViewController延迟问题/","link":"","permalink":"https://near2sea.github.io/2019/01/05/ios小结presentViewController延迟问题/","excerpt":"","text":"iOS小结(解决presentViewController延迟问题)在 iOS 中，当使用 1-(void)presentViewController:(UIViewController*)viewControllerToPresent animated:(BOOL)flag completion:(void (^__nullable)(void))completion 方法进行界面跳转的时候，有时候会出现延迟，这个延迟有时候会有好几秒的时间才会执行 completion，有时候干脆就一直不会跳转。 由于某种原因，presentViewController跳转时completion的内容并不会真的马上触发执行，除非有一个主线程事件触发这种消费。比如在弹出慢的时候，你随便点击一下屏幕，马上就能弹出来 所以得出相应的解决方法： 1.在主线程中执行跳转： 1234dispatch_async(dispatch_get_main_queue(), ^(void)&#123; [currentVC presentViewController:presentVC animated:YES completion:^&#123; &#125;]; &#125;); 2.在执行跳转前唤醒主线程,WakeUpMainThread方法它的作用只是唤醒主线程 1[self performSelectorOnMainThread:@selector(WakeUpMainThread) withObject:nil waitUntilDone:NO];","categories":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/tags/ios/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}]},{"title":"css技巧与经验","slug":"css技巧与经验","date":"2018-12-20T04:20:16.000Z","updated":"2018-12-20T04:21:54.235Z","comments":true,"path":"2018/12/20/css技巧与经验/","link":"","permalink":"https://near2sea.github.io/2018/12/20/css技巧与经验/","excerpt":"","text":"css使用技巧与经验 https://www.css88.com/book/css/experience/skill.htm","categories":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://near2sea.github.io/tags/css/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-18T00:51:39.402Z","updated":"2018-12-18T00:51:39.402Z","comments":true,"path":"2018/12/18/hello-world/","link":"","permalink":"https://near2sea.github.io/2018/12/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"zsh环境安装","slug":"zshhuan-jing-an-zhuang","date":"2018-12-15T03:19:54.000Z","updated":"2018-12-18T01:21:27.416Z","comments":true,"path":"2018/12/15/zshhuan-jing-an-zhuang/","link":"","permalink":"https://near2sea.github.io/2018/12/15/zshhuan-jing-an-zhuang/","excerpt":"","text":"oh-my-zsh 安装地址: https://github.com/robbyrussell/oh-my-zsh安装1.clone项目 1git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2.备份原来的 ~/.zshrc 1cp ~/.zshrc ~/.zshrc.orig 3.创建新的zsh配置文件，直接从项目模板文件复制过来 1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 4.设置系统默认shell环境 1chsh -s /bin/zsh 5.打开新的命令窗口，它已经加载Oh My Zsh的配置。 主题 powerlevel9k (https://github.com/bhilburn/powerlevel9k) 安装 Powerlevel9k 主题 1.Clone项目到OMZ的custom/themes目录. 1$ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 2.在~/.zshrc中设置主题.zshrc1ZSH_THEME=\"powerlevel9k/powerlevel9k\" 字体 安装Powerline字体 (https://github.com/powerline/fonts) 12345678# clone 项目git clone https://github.com/powerline/fonts.git --depth=1# 执行根目录下install.sh安装cd fonts./install.sh# 卸载时删掉目录cd ..rm -rf fonts 安装Awesome-Powerline Fonts字体 (https://github.com/gabrielelana/awesome-terminal-fonts) 参考系统字体安装 https://github.com/gabrielelana/awesome-terminal-fonts/wiki/OS-X 复制所有./build目录下的 *.sh 文件到~/.fonts目录 在~/.zshrc文件上添加source ~/.fonts/*.sh 在~/.zshrc文件上添加POWERLEVEL9K_MODE=&#39;awesome-fontconfig&#39; ./zshrc1234source ~/.fonts/*.shPOWERLEVEL9K_MODE='awesome-fontconfig'ZSH_THEME=\"powerlevel9k/powerlevel9k\" 插件 zsh-autosuggestions (https://github.com/zsh-users/zsh-autosuggestions) 1.clone项目$ZSH_CUSTOM/plugins (默认地址 ~/.oh-my-zsh/custom/plugins) 1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 2.把插件加入到Oh My Zsh的插件注册表(修改 ~/.zshrc, 每次修改完 .zshrc文件都需要source .zshrc) .zshrc1plugins=(zsh-autosuggestions) 3.打开新shell窗口 autojump (https://github.com/wting/autojump) 1.clone项目 1git clone git://github.com/wting/autojump.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/autojump 2.执行安装脚本12cd autojump./install.py or ./uninstall.py 3.执行完装脚本后之后把提示路径加到./zshrc文件中 zsh-syntax-highlighting (https://github.com/zsh-users/zsh-syntax-highlighting) 1.clone项目 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 2.加到插件列表 .zshrc1plugins=( [plugins...] zsh-syntax-highlighting) 3.执行 Source ~/.zshrc 1source ~/.zshrc ####VScode中配置 vscode环境中打开\b设置(command+,),设置终端字体settings.json1\"terminal.integrated.fontFamily\": \"'Meslo LG M DZ for Powerline'\" //终端样式 常用命令使用 history 查询历史使用命令 j folder 快速跳转到文件夹","categories":[{"name":"工具","slug":"工具","permalink":"https://near2sea.github.io/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://near2sea.github.io/categories/工具/"}]},{"title":"手机端调试H5","slug":"shou-ji-duan-diao-shi-h5","date":"2018-12-07T10:26:33.000Z","updated":"2018-12-18T00:51:39.400Z","comments":true,"path":"2018/12/07/shou-ji-duan-diao-shi-h5/","link":"","permalink":"https://near2sea.github.io/2018/12/07/shou-ji-duan-diao-shi-h5/","excerpt":"","text":"iOS调试h5 打开苹果手机web 检查器(设置 &gt; Safari浏览器 &gt; 高级 Web检查器),一般情况下默认是开启的 打开Mac 上的Safari的开发菜单 在Mac Aafari浏览器中选择调试页面(开发菜单 &gt; iphone &gt; 对应页面地址) 点击地址后弹出控制台，方便调试页面的元素、网络请求等 Android调试h5 手机打开usb调试模式，确保手机连上电脑, 打开chrome浏览器，输入chrome://inspect，远程调试页面","categories":[{"name":"h5","slug":"h5","permalink":"https://near2sea.github.io/categories/h5/"}],"tags":[],"keywords":[{"name":"h5","slug":"h5","permalink":"https://near2sea.github.io/categories/h5/"}]},{"title":"Vscode设置","slug":"vscodeshe-zhi","date":"2018-11-30T06:22:40.000Z","updated":"2019-06-24T01:43:45.077Z","comments":true,"path":"2018/11/30/vscodeshe-zhi/","link":"","permalink":"https://near2sea.github.io/2018/11/30/vscodeshe-zhi/","excerpt":"vscode开发工具设置 快捷键 command + , 打开设置，右上角打开 settings.json","text":"vscode开发工具设置 快捷键 command + , 打开设置，右上角打开 settings.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; \"workbench.iconTheme\": \"material-icon-theme\", \"materialTheme.fixIconsRunning\": false, \"editor.fontSize\": 16, // 字体大小 // 以下是代码格式化配置 \"editor.formatOnSave\": true, // 每次保存的时候自动格式化 \"editor.tabSize\": 2, // 代码缩进修改成2个空格 \"eslint.autoFixOnSave\": false, // 每次保存的时候将代码按eslint格式进行修复 \"prettier.eslintIntegration\": true, // 让prettier使用eslint的代码格式进行校验 \"prettier.semi\": false, // 去掉代码结尾的分号 \"prettier.singleQuote\": true, // 使用带引号替代双引号 \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, // 让函数(名)和后面的括号之间加个空格 \"vetur.format.defaultFormatter.html\": \"js-beautify-html\", //格式化.vue中html \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", //让vue中的js按编辑器自带的ts格式进行格式化 \"vetur.format.defaultFormatterOptions\": &#123; \"js-beautify-html\": &#123; \"wrap_attributes\": \"force-aligned\" //属性强制折行对齐 &#125; &#125;, \"eslint.validate\": [ //开启对.vue文件中错误的检查 \"javascript\", \"javascriptreact\", &#123; \"language\": \"html\", \"autoFix\": true &#125;, &#123; \"language\": \"vue\", \"autoFix\": true &#125; ], \"window.zoomLevel\": 0, \"editor.snippetSuggestions\": \"top\", \"editor.formatOnPaste\": true, \"explorer.confirmDelete\": false, \"todo-tree.defaultHighlight\": &#123; \"foreground\": \"green\", \"type\": \"none\" &#125;, \"todo-tree.customHighlight\": &#123; \"TODO\": &#123;&#125;, \"FIXME\": &#123;&#125; &#125;, \"git.autofetch\": true, \"terminal.integrated.fontFamily\": \"'Meslo LG M DZ for Powerline'\" //终端样式&#125; 打开工具栏 Code -&gt; 用户代码片段, 新件vue模板, vue.json, 在vue文件中，键入vue，按下tab键快速生成模板 1234567891011121314151617181920212223242526272829303132&#123; \"Print to console\": &#123; \"prefix\": \"vue\", \"body\": [ \"&lt;template&gt;\", \" &lt;div class=\\\"wrapper\\\"&gt;$0&lt;/div&gt;\", \"&lt;/template&gt;\", \"\", \"&lt;script&gt;\", \"export default &#123;\", \" components: &#123;&#125;,\", \" props: &#123;&#125;,\", \" data () &#123;\", \" return &#123;\", \" &#125;\", \" &#125;,\", \" watch: &#123;&#125;,\", \" computed: &#123;&#125;,\", \" methods: &#123;&#125;,\", \" created () &#123; &#125;,\", \" mounted () &#123; &#125;\", \"&#125;\", \"&lt;/script&gt;\", \"&lt;style lang=\\\"scss\\\" scoped&gt;\", \".wrapper &#123;\", \"&#125;\", \"&lt;/style&gt;\", \"$2\" ], \"description\": \"A vue file template\" &#125;&#125; vscode工具设置 https://code.visualstudio.com/docs/editor/userdefinedsnippets1234567891011121314151617181920&#123; \"Create Model Class\": &#123; \"scope\": \"dart\", \"prefix\": \"modelClass\", \"body\": [ \"import 'package:json_annotation/json_annotation.dart';\", \"\", \"part '$&#123;TM_FILENAME/(.*)\\\\.dart$/$&#123;1&#125;/gi&#125;.g.dart';\", \"@JsonSerializable()\", \"class $&#123;TM_FILENAME_BASE/\\\\w*/$&#123;0:/capitalize&#125;/&#125; &#123;\", \" $&#123;1:@JsonKey(name: \\\"tarball_url\\\")&#125;\", \" $&#123;2:String name;&#125;\", \" $&#123;TM_FILENAME_BASE/\\\\w*/$&#123;0:/capitalize&#125;/&#125;($&#123;3:this.name&#125;);\", \" factory $&#123;TM_FILENAME_BASE/\\\\w*/$&#123;0:/capitalize&#125;/&#125;.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$$&#123;TM_FILENAME_BASE/\\\\w*/$&#123;0:/capitalize&#125;/&#125;FromJson(json);\", \" Map&lt;String, dynamic&gt; toJson() =&gt; _$$&#123;TM_FILENAME_BASE/\\\\w*/$&#123;0:/capitalize&#125;/&#125;ToJson(this);\", \"&#125;\" ], \"description\": \"Dart Create Model Class\" &#125;&#125; vscode快捷键使用 command+K command+Q 快速定位最后一次文件修改的地方 command+K command+S 快捷键映射列表 command+P 转到文件 ctrl + ` 打开终端 command+shift+O 转到文件中的符号 command+B 隐藏或显示侧边栏 command+shift+剪头右 选择光标后的文字","categories":[{"name":"工具","slug":"工具","permalink":"https://near2sea.github.io/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://near2sea.github.io/categories/工具/"}]},{"title":"img标签src引用网络图片不显示","slug":"imgbiao-qian-srcyin-yong-wang-luo-tu-pian-bu-xian-shi","date":"2018-11-27T12:29:26.000Z","updated":"2018-12-18T00:51:39.399Z","comments":true,"path":"2018/11/27/imgbiao-qian-srcyin-yong-wang-luo-tu-pian-bu-xian-shi/","link":"","permalink":"https://near2sea.github.io/2018/11/27/imgbiao-qian-srcyin-yong-wang-luo-tu-pian-bu-xian-shi/","excerpt":"","text":"在src中引用网络图片无法显示，这因为在引用链接时,浏览器对地址发起请求加上了refre这个请求头,而有些服务器能根据refre反盗所以引用失败返回403。解决方法：1&lt;meta name=\"referrer\" content=\"no-referrer\"&gt;","categories":[{"name":"h5","slug":"h5","permalink":"https://near2sea.github.io/categories/h5/"}],"tags":[],"keywords":[{"name":"h5","slug":"h5","permalink":"https://near2sea.github.io/categories/h5/"}]},{"title":"git命令","slug":"gitming-ling","date":"2018-11-14T06:37:28.000Z","updated":"2018-12-18T00:51:39.399Z","comments":true,"path":"2018/11/14/gitming-ling/","link":"","permalink":"https://near2sea.github.io/2018/11/14/gitming-ling/","excerpt":"一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]","text":"一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"git","slug":"git","permalink":"https://near2sea.github.io/categories/git/"}],"tags":[],"keywords":[{"name":"git","slug":"git","permalink":"https://near2sea.github.io/categories/git/"}]},{"title":"阿里云移动平台集成","slug":"a-li-yun-yi-dong-ping-tai-ji-cheng","date":"2018-11-08T04:00:12.000Z","updated":"2018-12-18T00:51:39.397Z","comments":true,"path":"2018/11/08/a-li-yun-yi-dong-ping-tai-ji-cheng/","link":"","permalink":"https://near2sea.github.io/2018/11/08/a-li-yun-yi-dong-ping-tai-ji-cheng/","excerpt":"","text":"移动数据分析 获取alicloud-ios-demo工程源码例子 参考移动数据分析API文档 代码示例 12345678910111213ALBBMANPageHitBuilder *pageHitBuilder = [[ALBBMANPageHitBuilder alloc] init];// 设置页面refer[pageHitBuilder setReferPage:@&quot;pageRefer&quot;];// 设置页面名称[pageHitBuilder setPageName:@&quot;pageName&quot;];// 设置页面停留时间[pageHitBuilder setDurationOnPage:100];// 设置页面事件扩展参数[pageHitBuilder setProperty:@&quot;pagePropertyKey1&quot; value:@&quot;pagePropertyValue1&quot;];[pageHitBuilder setProperty:@&quot;pagePropertyKey2&quot; value:@&quot;pagePropertyValue2&quot;];ALBBMANTracker *tracker = [[ALBBMANAnalytics getInstance] getDefaultTracker];// 组装日志并发送[tracker send:[pageHitBuilder build]]; 页面埋点与页面事件将影响控制台【页面路径分析】、【关键漏斗】、【控件点击】、【页面留存】等指标的报表展现，页面路径如下图所示。","categories":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/categories/ios/"}]},{"title":"ios上加AppStore异常","slug":"iosshang-jia-appstoreyi-chang","date":"2018-11-08T01:32:34.000Z","updated":"2018-12-18T00:51:39.398Z","comments":true,"path":"2018/11/08/iosshang-jia-appstoreyi-chang/","link":"","permalink":"https://near2sea.github.io/2018/11/08/iosshang-jia-appstoreyi-chang/","excerpt":"upload到appStore时xcode出来的异常信息","text":"upload到appStore时xcode出来的异常信息 正在上传 上传异常 苹果icon尺寸参考 https://developer.apple.com/design/human-interface-guidelines/watchos/icons-and-images/home-screen-icons/","categories":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/categories/ios/"}]},{"title":"Vue环境搭建","slug":"vuehuan-jing-da-jian","date":"2018-11-05T04:20:23.000Z","updated":"2018-12-18T01:20:19.328Z","comments":true,"path":"2018/11/05/vuehuan-jing-da-jian/","link":"","permalink":"https://near2sea.github.io/2018/11/05/vuehuan-jing-da-jian/","excerpt":"vsCode插件安装 安装插件： https://zhangzhenfei.github.io/15337782581565.html","text":"vsCode插件安装 安装插件： https://zhangzhenfei.github.io/15337782581565.html 授权安装目录 执行sudo chown -R $(whoami) /usr/local/lib目录授权 安装nvm (node版本管理) curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash #执行后添加nvm添加环境变量 123456789101112131415161718192021222324252627282930=&gt; Profile not found. Tried ~/.bashrc, ~/.bash_profile, ~/.zshrc, and ~/.profile.=&gt; Create one of them and run this script again OR=&gt; Append the following lines to the correct file yourself:export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm=&gt; You currently have modules installed globally with `npm`. These will no=&gt; longer be linked to the active version of Node when you install a new node=&gt; with `nvm`; and they may (depending on how you construct your `$PATH`)=&gt; override the binaries of modules installed with `nvm`:/usr/local/lib├── @angular/cli@1.7.2├── @vue/cli@3.0.0-beta.2├── @vue/cli-init@3.0.0-beta.2├── ionic@3.19.1├── node-sass@4.7.2└── whistle@1.10.10=&gt; If you wish to uninstall them at a later point (or re-install them under your=&gt; `nvm` Nodes), you can remove them from the system Node as follows: $ nvm use system $ npm uninstall -g a_module=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 添加nvm到环境变量 两个环境 vim ~/.bash_profile与vim ~/.zshrc 添加文档最末，重启shell 执行vi ~/.zshrc打开.zshrc,将source $HOME/.bash_profile粘贴到最下面，保存即可。 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; nvm ls-remote 列表可安装的Node.js版本 执行 nvm install 8.11.4 安装node指定版本 执行 nvm uninstall 8.11.4 卸载node指定版本 执行 nvm use 8.11.4 设置shell的node版本 nvm deactivate 还原环境变量PATH .nvmrc echo 6.2.1 &gt; .nvmrc 它存储在工程根目录中，用于记录该工程依赖的Node.js版本 进入工程目录（当前目录），运行 nvm use ,将根据.nvmrc指定shell的Nodejs版本 执行npm i -g cnpm安装淘宝源 使用nrm安装 npm install -g nrm #安装nrm nrm add syt http://npm.sythealth.com #添加公司的npm镜像地址 nrm use syt #使用公司npm地址 nrm ls查看源 12345678 npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/* syt ---- http://npm.sythealth.com/ 使用yarn安装 npm i -g yarn yarn相当于是npm的升级 npm i -g yrm yrm add syt http://npm.sythealth.com yrm ls # 123456789* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ yarn --- https://registry.yarnpkg.com syt ---- http://npm.sythealth.com/ yrm use syt 123456789 npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ yarn --- https://registry.yarnpkg.com* syt ---- http://npm.sythealth.com/ 进入项目根目录 执行 安装项目依赖1* 执行下面安装chromedriver谷歌驱动 npm install chromedriver –chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver1234### 解决项目安装chromedriver失败问题* 使用npm解决方式 npm config set chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver12* 使用yarn解决方式 yarn config set “chromedriver_cdnurl” “https://npm.taobao.org/mirrors/chromedriver&quot;` APPStore安装Helm,切换host环境chrome浏览器安装vue插件项目启动 npm run dev #启动项目","categories":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://near2sea.github.io/categories/前端/"}]},{"title":"Vue 应用性能优化指南","slug":"vue-ying-yong-xing-neng-you-hua-zhi-nan","date":"2018-10-31T10:33:02.000Z","updated":"2018-12-18T00:51:39.396Z","comments":true,"path":"2018/10/31/vue-ying-yong-xing-neng-you-hua-zhi-nan/","link":"","permalink":"https://near2sea.github.io/2018/10/31/vue-ying-yong-xing-neng-you-hua-zhi-nan/","excerpt":"Vue 应用性能优化指南得益于 Vue 的 响应式系统 和 虚拟 DOM 系统 ，Vue 在渲染组件的过程中能自动追踪数据的依赖，并精确知晓数据更新的时候哪个组件需要重新渲染，渲染之后也会经过虚拟 DOM diff 之后才会真正更新到 DOM 上，Vue 应用的开发者一般不需要做额外的优化工作。 但在实践中仍然有可能遇到性能问题，下面会介绍一些定位分析 Vue 应用性能问题的方式及一些优化的建议。","text":"Vue 应用性能优化指南得益于 Vue 的 响应式系统 和 虚拟 DOM 系统 ，Vue 在渲染组件的过程中能自动追踪数据的依赖，并精确知晓数据更新的时候哪个组件需要重新渲染，渲染之后也会经过虚拟 DOM diff 之后才会真正更新到 DOM 上，Vue 应用的开发者一般不需要做额外的优化工作。 但在实践中仍然有可能遇到性能问题，下面会介绍一些定位分析 Vue 应用性能问题的方式及一些优化的建议。 整体内容由三部分组成： 如何定位 Vue 应用性能问题 Vue 应用运行时性能优化建议 Vue 应用加载性能优化建议 1. 如何定位 Vue 应用性能问题Vue 应用的性能问题可以分为两个部分，第一部分是运行时性能问题，第二部分是加载性能问题。 和其他 web 应用一样，定位 Vue 应用性能问题最好的工具是 Chrome Devtool，通过 Performance 工具可以用来录制一段时间的 CPU 占用、内存占用、FPS 等运行时性能问题，通过 Network 工具可以用来分析加载性能问题。 例如，通过 Performance 工具的 Bottom Up 标签我们可以看出一段时间内耗时最多的操作，这对于优化 CPU 占用和 FPS 过低非常有用，可以看出最为耗时的操作发生在哪里，可以知道具体函数的执行时间，定位到瓶颈之后，我们就可以做一些针对性的优化。 2. Vue 应用运行时性能优化建议运行时性能主要关注 Vue 应用初始化之后对 CPU、内存、本地存储等资源的占用，以及对用户交互的及时响应。下面是一些有用的优化手段： 2.1 引入生产环境的 Vue 文件开发环境下，Vue 会提供很多警告来帮你对付常见的错误与陷阱。而在生产环境下，这些警告语句没有用，反而会增加应用的体积。有些警告检查还有一些小的运行时开销。 当使用 webpack 或 Browserify 类似的构建工具时，Vue 源码会根据 process.env.NODE_ENV 决定是否启用生产环境模式，默认情况为开发环境模式。在 webpack 与 Browserify 中都有方法来覆盖此变量，以启用 Vue 的生产环境模式，同时在构建过程中警告语句也会被压缩工具去除 2.2 使用单文件组件预编译模板当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。 预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。 详细的做法请参阅 预编译模板 2.3 提取组件的 CSS 到单独到文件当使用单文件组件时，组件内的 CSS 会以 &lt;style&gt; 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。 查阅这个构建工具各自的文档来了解更多： webpack + vue-loader (vue-cli 的 webpack 模板已经预先配置好) Browserify + vueify Rollup + rollup-plugin-vue 2.4 利用Object.freeze()提升性能Object.freeze() 可以冻结一个对象，冻结之后不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter，这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 但 Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法。参考 Vue 源码 2.5 扁平化 Store 数据结构很多时候，我们会发现接口返回的信息是如下的深层嵌套的树形结构： 1234567891011121314151617&#123; \"id\": \"123\", \"author\": &#123; \"id\": \"1\", \"name\": \"Paul\" &#125;, \"title\": \"My awesome blog post\", \"comments\": [ &#123; \"id\": \"324\", \"commenter\": &#123; \"id\": \"2\", \"name\": \"Nicole\" &#125; &#125; ]&#125; 假如直接把这样的结构存储在 store 中，如果想修改某个 commenter 的信息，我们需要一层层去遍历找到这个用户的信息，同时有可能这个用户的信息出现了多次，还需要把其他地方的用户信息也进行修改，每次遍历的过程会带来额外的性能开销。 假设我们把用户信息在 store 内统一存放成 users[id]这样的结构，修改和读取用户信息的成本就变得非常低。 你可以手动去把接口里的信息通过类似数据的表一样像这样存起来，也可以借助一些工具，这里就需要提到一个概念叫做 JSON数据规范化（normalize）, Normalizr 是一个开源的工具，可以将上面的深层嵌套的 JSON 对象通过定义好的 schema 转变成使用 id 作为字典的实体表示的对象。 举个例子，针对上面的 JSON 数据，我们定义 users comments articles 三种 schema： 1234567891011121314151617import &#123;normalize, schema&#125; from 'normalizr';// 定义 users schemaconst user = new schema.Entity('users');// 定义 comments schemaconst comment = new schema.Entity('comments', &#123; commenter: user,&#125;);// 定义 articles schemaconst article = new schema.Entity('articles', &#123; author: user, comments: [comment],&#125;);const normalizedData = normalize(originalData, article); normalize 之后就可以得到下面的数据，我们可以按照这种形式存放在 store 中，之后想修改和读取某个 id 的用户信息就变得非常高效了，时间复杂度降低到了 O(1)。 1234567891011121314151617181920&#123; result: \"123\", entities: &#123; \"articles\": &#123; \"123\": &#123; id: \"123\", author: \"1\", title: \"My awesome blog post\", comments: [ \"324\" ] &#125; &#125;, \"users\": &#123; \"1\": &#123; \"id\": \"1\", \"name\": \"Paul\" &#125;, \"2\": &#123; \"id\": \"2\", \"name\": \"Nicole\" &#125; &#125;, \"comments\": &#123; \"324\": &#123; id: \"324\", \"commenter\": \"2\" &#125; &#125; &#125;&#125; 需要了解更多请参考 normalizr 的文档 https://github.com/paularmstrong/normalizr 2.6 避免持久化 Store 数据带来的性能问题当你有让 Vue App 离线可用，或者有接口出错时候进行灾备的需求的时候，你可能会选择把 Store 数据进行持久化，这个时候需要注意以下几个方面： 2.6.1 持久化时写入数据的性能问题Vue 社区中比较流行的 vuex-persistedstate，利用了 store 的 subscribe 机制，来订阅 Store 数据的 mutation，如果发生了变化，就会写入 storage 中，默认用的是 localstorage 作为持久化存储。 也就是说默认情况下每次 commit 都会向 localstorage 写入数据，localstorage 写入是同步的，而且存在不小的性能开销，如果你想打造 60fps 的应用，就必须避免频繁写入持久化数据 下面是开发环境下通过 Performance 工具抓取的一个截图，可以看到出现了一次长达 6s 的卡顿： 6秒钟的卡顿 通过 Bottom-Up 可以看到 setState 占用了 3241.4ms 的 CPU 执行时间，而 setState 正是在向 Storage 写入数据。 vuex-persistedstate setState 源码 我们应该尽量减少直接写入 Storage 的频率： 多次写入操作合并为一次，比如采用函数节流或者将数据先缓存在内存中，最后在一并写入只有在必要的时候才写入，比如只有关心的模块的数据发生变化的时候才写入 2.6.2 避免持久化存储的容量持续增长由于持久化缓存的容量有限，比如 localstorage 的缓存在某些浏览器只有 5M，我们不能无限制的将所有数据都存起来，这样很容易达到容量限制，同时数据过大时，读取和写入操作会增加一些性能开销，同时内存也会上涨。 尤其是将 API 数据进行 normalize 数据扁平化后之后，会将一份数据散落在不同的实体上，下次请求到新的数据也会散落在其他不同的实体上，这样会带来持续的存储增长。 因此，当设计了一套持久化的数据缓存策略的时候，同时应该设计旧数据的缓存清除策略，例如请求到新数据的时候将旧的实体逐个进行清除。 2.7 优化无限列表性能如果你的应用存在非常长或者无限滚动的列表，那么采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 vue-virtual-scroll-list 和 vue-virtual-scroller 都是解决这类问题的开源项目。你也可以参考 Google 工程师的文章Complexities of an Infinite Scroller 来尝试自己实现一个虚拟的滚动列表来优化性能，主要使用到的技术是 DOM 回收、墓碑元素和滚动锚定。 Google 工程师绘制的无限列表设计 2.8 通过组件懒加载优化超长应用内容初始渲染性能上面提到的无限列表的场景，比较适合列表内元素非常相似的情况，不过有时候，你的 Vue 应用的超长列表内的内容往往不尽相同，例如在一个复杂的应用的主界面中，整个主界面由非常多不同的模块组成，而用户看到的往往只有首屏一两个模块。在初始渲染的时候不可见区域的模块也会执行和渲染，带来一些额外的性能开销。 使用组件懒加载在不可见时只需要渲染一个骨架屏，不需要真正渲染组件 你可以对组件直接进行懒加载，对于不可见区域的组件内容，直接不进行加载和初始化，避免初始化渲染运行时的开销。具体可以参考我们之前的专栏文章 性能优化之组件懒加载: Vue Lazy Component 介绍，了解如何做到组件粒度的懒加载。 3. Vue 应用加载性能优化建议3.1 利用服务端渲染（SSR）和预渲染（Prerender）来优化加载性能在一个单页应用中，往往只有一个 html 文件，然后根据访问的 url 来匹配对应的路由脚本，动态地渲染页面内容。单页应用比较大的问题是首屏可见时间过长。 单页面应用显示一个页面会发送多次请求，第一次拿到 html 资源，然后通过请求再去拿数据，再将数据渲染到页面上。而且由于现在微服务架构的存在，还有可能发出多次数据请求才能将网页渲染出来，每次数据请求都会产生 RTT（往返时延），会导致加载页面的时间拖的很长。 服务端渲染、预渲染和客户端渲染的对比 这种情况下可以采用服务端渲染（SSR）和预渲染（Prerender）来提升加载性能，这两种方案，用户读取到的直接就是网页内容，由于少了节省了很多 RTT（往返时延），同时，还可以对一些资源内联在页面，可以进一步提升加载的性能。 可以参考我们的专栏文章 优化向：单页应用多路由预渲染指南 了解如何利用预渲染进行优化。 服务端渲染（SSR）可以考虑使用 Nuxt 或者按照 Vue 官方提供的 Vue SSR 指南来一步步搭建。 3.2 通过组件懒加载优化超长应用内容加载性能在上面提到的超长应用内容的场景中，通过组件懒加载方案可以优化初始渲染的运行性能，其实，这对于优化应用的加载性能也很有帮助。 组件粒度的懒加载结合异步组件和 webpack 代码分片，可以保证按需加载组件，以及组件依赖的资源、接口请求等，比起通常单纯的对图片进行懒加载，更进一步的做到了按需加载资源。 使用组件懒加载之前的请求瀑布图 使用组件懒加载之后的请求瀑布图 使用组件懒加载方案对于超长内容的应用初始化渲染很有帮助，可以减少大量必要的资源请求，缩短渲染关键路径，具体做法请参考我们之前的专栏文章 性能优化之组件懒加载: Vue Lazy Component 介绍。 总结本文总结了 Vue 应用运行时以及加载时的一些性能优化措施，下面做一个回顾和概括： Vue 应用运行时性能优化措施 引入生产环境的 Vue 文件 使用单文件组件预编译模板 提取组件的 CSS 到单独到文件 利用Object.freeze()提升性能 扁平化 Store 数据结构 合理使用持久化 Store 数据 组件懒加载 Vue 应用加载性能优化措施 服务端渲染 / 预渲染 组件懒加载 文章出处Vue 应用性能优化指南作者：binggg_xunlei","categories":[{"name":"vue","slug":"vue","permalink":"https://near2sea.github.io/categories/vue/"}],"tags":[],"keywords":[{"name":"vue","slug":"vue","permalink":"https://near2sea.github.io/categories/vue/"}]},{"title":"授权苹果健康","slug":"shou-quan-ping-guo-jian-kang","date":"2018-10-29T09:56:18.000Z","updated":"2018-12-18T00:51:39.395Z","comments":true,"path":"2018/10/29/shou-quan-ping-guo-jian-kang/","link":"","permalink":"https://near2sea.github.io/2018/10/29/shou-quan-ping-guo-jian-kang/","excerpt":"简述 HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 HealthKit另外提供了一个应用来帮助管理用户的健康数据。健康应用为用户展示HealthKit的数据。用户可以使用健康应用来查看、添加、删除或者管理其全部的健康和健身数据。用户还可以编辑每种数据类型的分享权限。","text":"简述 HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 HealthKit另外提供了一个应用来帮助管理用户的健康数据。健康应用为用户展示HealthKit的数据。用户可以使用健康应用来查看、添加、删除或者管理其全部的健康和健身数据。用户还可以编辑每种数据类型的分享权限。 使用HealthKit特别注意 应用不应该将HealthKit收集的数据用于广告或类似的服务。注意，在使用HealthKit框架应用中可以插播广告，但是你不能使用HealthKit中的数据来服务广告。 在没有用户的明确允许下，你不能向第三方展示任何HealthKit收集的数据。即使用户允许，你也只能向提供健康或健身服务的第三方展示这些数据。 你不能将HealthKit收集的数据出售给广告平台、数据代理人或者信息经销商。 如果用户允许，你可以将HealthKit数据共享给第三方用于医学研究。注意是用户允许 必须明确说明，你和你的应用会怎样使用用户的HealthKit数据。 应用中使用了HealthKit 上 App Store 特别注意 一定要添加隐私政策网址链接,并注明健康数据使用的隐私相关条例。例如： 在App里您设置身高、体重时，根据您之前是否允许授权权限，XXX将依据您给的权限是否把信息写入苹果健康应用。 在App里同步计步、睡眠、心率数据时，根据您之前是否允许授权权限，XXX将依据您给的权限是否把信息写入苹果健康应用。 应用介绍中一定要注明：此版本支持你使用Apple健康应用程序 审核详情请参考 App Store Review Guidelines中的HealthKit章节。 HealthKit 存储理念 框架大量使用了子类化，在相似的类间创建层级关系。通常这些类间都有一些细微但是重要的差别。还有不少和它相关的类，需要正确搭配,才能一起工作。存储在HealthKit中的数据都是由对象和对象所属类型组成,这个概念一定要刻入脑海,你才能理解整个存储结构。所有对象都是基于HKObject，所有对象所属的类型都是基于HKObjectType。下面简单介绍下这两个类: HKObject我们不能直接使用,而是使用它的子类。子类有: 样本对象是某个特定时间断的数据。所有的样本对象都是HKSample的子类。它们都有下列属性： sampleType: 样本类型。例如：一个睡眠分析样本、一个身高样本或者一个计步样本。 startDate : 样本的开始时间。 endDate : 样本的结束时间。 注意bugly异常分析中看到，但项目的Info.plist文件已经添加了NSHealthUpdateUsageDescription，但还是会报错。1NSHealthUpdateUsageDescription must be set in the app&apos;s Info.plist in order to request write authorization for the following types: HKQuantityTypeIdentifierBodyMassIndex, HKQuantityTypeIdentifierActiveEnergyBurned, HKWorkoutTypeIdentifier 处理方法： 先把Info.plist中的key值为NSHealthUpdateUsageDescription删掉 重新Info.plist中添加NSHealthUpdateUsageDescription并加上文字描述，OK!","categories":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://near2sea.github.io/categories/ios/"}]},{"title":"Octopress插件使用","slug":"gist-tagshi-yong","date":"2018-10-26T04:17:16.000Z","updated":"2018-12-18T00:51:39.395Z","comments":true,"path":"2018/10/26/gist-tagshi-yong/","link":"","permalink":"https://near2sea.github.io/2018/10/26/gist-tagshi-yong/","excerpt":"octopress插件使用codeblock插件1Awesome code snippet","text":"octopress插件使用codeblock插件1Awesome code snippet Last night I lay in bed looking up at the stars in the sky and I thought to myself, where the heck is the ceiling. Last night I lay in bed looking up at the stars in the sky and I thought to myself, where the heck is the ceiling. 发邮件反馈插件 https://getsimpleform.com/ 集成图表 http://mostlyblather.com/blog/2015/05/23/mermaid-jekyll-octopress/ octopress转到hexo https://changchen.me/blog/20180807/octopress-to-hexo/ octopress集成OTC https://github.com/dafi/jekyll-toc-generator 安装nokogiri To use tocGenerator.rb you need nokogiri copy the file tocGenerator.rb into the _plugins folder copy the file css/toc.css to you css site and include into _layouts (this is recommended but not necessary) finished 如何使用source/_layout/default.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8' /&gt; &lt;title&gt;&#123;&#123; page.title &#125;&#125;&lt;/title&gt; &lt;!-- This css contains the default style for TOC --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"css/toc.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &#123;&#123; content | toc_generate &#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 安装category插件 创建文件 category_list.rb，放在pluginss目录下 plugins/category_list.rb1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071module Jekyll class CategoryCloud &lt; Liquid::Tag def initialize(tag_name, markup, tokens) @opts = &#123;&#125; if markup.strip =~ /\\s*counter:(\\w+)/iu @opts['counter'] = ($1 == 'true') markup = markup.strip.sub(/counter:\\w+/iu,'') end super end def render(context) lists = &#123;&#125; max, min = 1, 1 config = context.registers[:site].config category_dir = config['root'] + config['category_dir'] + '/' categories = context.registers[:site].categories categories.keys.sort_by&#123; |str| str.downcase &#125;.each do |category| count = categories[category].count lists[category] = count max = count if count &gt; max end html = '' lists.each do | category, counter | url = category_dir + category.to_url.gsub(/_|\\P&#123;Word&#125;/u, '-').gsub(/-&#123;2,&#125;/u, '-').downcase style = \"font-size: #&#123;100 + (60 * Float(counter)/max)&#125;%\" html &lt;&lt; \"&lt;a href='#&#123;url&#125;' style='#&#123;style&#125;'&gt;#&#123;category&#125;\" if @opts['counter'] html &lt;&lt; \"(#&#123;categories[category].count&#125;)\" end html &lt;&lt; \"&lt;/a&gt; \" end html end end class CategoryList &lt; Liquid::Tag def initialize(tag_name, markup, tokens) @opts = &#123;&#125; if markup.strip =~ /\\s*counter:(\\w+)/iu @opts['counter'] = ($1 == 'true') markup = markup.strip.sub(/counter:\\w+/iu,'') end super end def render(context) html = \"\" config = context.registers[:site].config category_dir = config['root'] + config['category_dir'] + '/' categories = context.registers[:site].categories categories.keys.sort_by&#123; |str| str.downcase &#125;.each do |category| url = category_dir + category.to_url.gsub(/_|\\P&#123;Word&#125;/u, '-').gsub(/-&#123;2,&#125;/u, '-').downcase html &lt;&lt; \"&lt;li&gt;&lt;a href='#&#123;url&#125;'&gt;#&#123;category&#125;\" if @opts['counter'] html &lt;&lt; \" (#&#123;categories[category].count&#125;)\" end html &lt;&lt; \"&lt;/a&gt;&lt;/li&gt;\" end html end endendLiquid::Template.register_tag('category_cloud', Jekyll::CategoryCloud)Liquid::Template.register_tag('category_list', Jekyll::CategoryList) 在目录source/_includes/custom/asides 创建category_list.html category_list.html1234&lt;section&gt; &lt;h1&gt;Categories&lt;/h1&gt; &lt;ul id=\"category-list\"&gt;&#123; % category_list counter:true % &#125;&lt;/ul&gt;&lt;/section&gt; 修改根目录下的_config.yml文件 _config.yml1default_asides: [..., custom/asides/category_list.html] 在目录blog/categories/ 创建 all.html all.html1234567---layout: pagetitle: \"categories\"footer: false---&#123; % category_list [counter:true] % &#125; 修改目录source/_includes/custom/navigation.html文件，增加一个分类入口 source/_includes/custom/navigation.html123456&lt;ul class=\"main-navigation\"&gt; &lt;li&gt;&lt;a href=\"&#123;&#123; root_url &#125;&#125;/\"&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&#123;&#123; root_url &#125;&#125;/blog/archives\"&gt;Archives&lt;/a&gt;&lt;/li&gt; &lt;!-- 增加分类入口 --&gt; &lt;li&gt;&lt;a href=\"&#123;&#123; root_url &#125;&#125;/blog/categories/all.html\"&gt;Categories&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;","categories":[{"name":"插件","slug":"插件","permalink":"https://near2sea.github.io/categories/插件/"}],"tags":[],"keywords":[{"name":"插件","slug":"插件","permalink":"https://near2sea.github.io/categories/插件/"}]},{"title":"EasyReact初识","slug":"dai-ma-pian-duan-gao-liang","date":"2018-10-25T02:03:04.000Z","updated":"2018-12-18T00:51:39.394Z","comments":true,"path":"2018/10/25/dai-ma-pian-duan-gao-liang/","link":"","permalink":"https://near2sea.github.io/2018/10/25/dai-ma-pian-duan-gao-liang/","excerpt":"美团客户端响应式框架 EasyReact前言EasyReact 是一款基于响应式编程范式的客户端开发框架，开发者可以使用此框架轻松地解决客户端的异步问题。 目前 EasyReact 已在美团和大众点评客户端的部分业务中实践，并且持续迭代了一年多的时间。近日，我们决定开源这个项目的 iOS Objective-C 语言部分，希望能够帮助更多的开发者不断探索更广泛的业务场景，也欢迎更多的社区的开发者跟我们一起加强 EasyReact 的功能。Github 的项目地址，参见 https://github.com/meituan/EasyReact 。","text":"美团客户端响应式框架 EasyReact前言EasyReact 是一款基于响应式编程范式的客户端开发框架，开发者可以使用此框架轻松地解决客户端的异步问题。 目前 EasyReact 已在美团和大众点评客户端的部分业务中实践，并且持续迭代了一年多的时间。近日，我们决定开源这个项目的 iOS Objective-C 语言部分，希望能够帮助更多的开发者不断探索更广泛的业务场景，也欢迎更多的社区的开发者跟我们一起加强 EasyReact 的功能。Github 的项目地址，参见 https://github.com/meituan/EasyReact 。 响应式编程的学习门槛前面已经分析过，单纯的响应式编程并不是特别的难以理解，而函数式编程才是造成高学习门槛的原因。因此 EasyReact 采用大家都熟知的面向对象编程进行设计， 想要了解代码，相对于函数式编程变得容易很多。 另外响应式编程基于数据流动，流动就会产生一个有向的流动网络图。在函数式编程中，网络图是使用闭包捕获来建立的，这样做非常不利于图的查找和遍历。而 EasyReact 选择在框架中使用图的数据结构，将数据流动的有向网络图抽象成有向有环图的节点和边。这样使得框架在运行过程中可以随时查询到节点和边的关系，详细内容可以参见 框架概述 。 另外对于已经熟悉了 ReactiveCocoa 的同学来说，我们也在数据的流动操作上基本实现了 ReactiveCocoa API。详细内容可以参见 基本操作 。更多的功能可以向我们提功能的 ISSUE ，也欢迎大家能够提 Pull Request 来共同建设 EasyReact。 EasyReact的最佳实践通常我们创建一个类，里面会包含很多的属性。在使用 EasyReact 时，我们通常会把这些属性包装为 EZRNode 并加上一个泛型。如： SearchService.h1234567@interface SearchService : NSObject@property (nonatomic, readonly, strong) EZRMutableNode *param;@property (nonatomic, readonly, strong) EZRNode *result;@property (nonatomic, readonly, strong) EZRNode *error;@end 这段代码展示了如何创建一个 WiKi 查询服务，该服务接收一个 param 参数，查询后会返回 result 或者 error。以下是实现部分： SearchService.m12345678910111213141516171819202122232425262728293031323334353637@implementation SearchService- (instancetype)init &#123; if (self = [super init]) &#123; _param = [EZRMutableNode new]; EZRNode *resultNode = [_param flattenMap:^EZRNode * _Nullable(NSString * _Nullable searchParam) &#123; NSString *queryKeyWord = [searchParam stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@\"https://en.wikipedia.org/w/api.php?action=query&amp;titles=%@∝=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2\", queryKeyWord]]; EZRMutableNode *returnedNode = [EZRMutableNode new]; [[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; returnedNode.value = error; &#125; else &#123; NSError *serializationError; NSDictionary *resultDictionary = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;serializationError]; if (serializationError) &#123; returnedNode.value = serializationError; &#125; else if (!([resultDictionary[@\"query\"][@\"pages\"] count] &amp;&amp; !resultDictionary[@\"query\"][@\"pages\"][0][@\"missing\"])) &#123; NSError *notFoundError = [NSError errorWithDomain:@\"com.example.service.wiki\" code:100 userInfo:@&#123;NSLocalizedDescriptionKey: [NSString stringWithFormat:@\"keyword '%@' not found.\", searchParam]&#125;]; returnedNode.value = notFoundError; &#125; else &#123; returnedNode.value = resultDictionary; &#125; &#125; &#125;]; return returnedNode; &#125;]; EZRIFResult *resultAnalysedNode = [resultNode if:^BOOL(id _Nullable next) &#123; return [next isKindOfClass:NSDictionary.class]; &#125;]; _result = resultAnalysedNode.thenNode; _error = resultAnalysedNode.elseNode; &#125; return self;&#125;@end 在调用时，我们只需要通过 listenedBy 方法关注节点的变化： ViewController.m12345678910self.service = [SearchService new];[[self.service.result listenedBy:self] withBlock:^(NSDictionary * _Nullable next) &#123; NSLog(@\"Result: %@\", next);&#125;];[[self.service.error listenedBy:self] withBlock:^(NSError * _Nullable next) &#123; NSLog(@\"Error: %@\", next);&#125;];self.service.param.value = @\"mipmap\"; //should print search resultself.service.param.value = @\"420v\"; // should print error, keyword not found. 使用 EasyReact 后，网络请求的参数、结果和错误可以很好地被分离。不需要像命令式的写法那样在网络请求返回的回调中写一堆判断来分离结果和错误。 因为节点的存在先于结果，我们能对暂时还没有得到的结果构建连接关系，完成整个响应链的构建。响应链构建之后，一旦有了数据，数据便会自动按照我们预期的构建来传递。 在这个例子中，我们不需要显式地来调用网络请求，只需要给响应链中的 param 节点赋值，框架就会主动触发网络请求，并且请求完成之后会根据网络返回结果来分离出 result 和 error 供上层业务直接使用。","categories":[],"tags":[],"keywords":[]},{"title":"搭建Octopress","slug":"da-jian-octopress","date":"2018-10-24T04:07:05.000Z","updated":"2018-12-18T00:51:39.393Z","comments":true,"path":"2018/10/24/da-jian-octopress/","link":"","permalink":"https://near2sea.github.io/2018/10/24/da-jian-octopress/","excerpt":"在Github上像是写代码一样写博客有一段时间了，有必要把搭建博客的方法整理一下，方便更多的人DIY，享受一下“博客驱动开发”。","text":"在Github上像是写代码一样写博客有一段时间了，有必要把搭建博客的方法整理一下，方便更多的人DIY，享受一下“博客驱动开发”。 Octopress是Brandon Mathis在Jekyll上开发的，利用Github Pages来展示静态页面。 正如Octopress网站所说的 Octopress is a blogging framework for hackers. You should be comfortable running shell commands and familiar with the basics of Git. 所以如果你不喜欢这种方式，可以选择其他博客平台或框架，毕竟工具就是为了让我们效率最大化而不是造成困惑。 本文是基于OS X系统进行介绍的。 ##准备工作 安装Git。 安装Ruby 1.9.3。 在Mac上使用brew安装Git： 1$ brew install git 同样的，使用brew安装rbenv之后，使用rbenv安装所需要的Ruby版本： 12$ brew install rbenv$ rbenv rehash 安装好后可以进行验证：12$ git version$ rbenv version ##搭建博客 首先使用Git将Octopress从Github上clone到本地： 12$ git clone git@github.com:imathis/octopress.git octopress$ cd octopress 紧接着，安装依赖： 123$ gem install bundler$ rbenv rehash$ bundle install 安装默认的Octopress主题： 1$ rake install ##选择博客主题 有很多第三方的Octopress主题可供选择——3rd Party Octopress Themes。 通过git submodule add将需要的主题项目加为子模块，接着安装主题： 123$ git submodule add GIT_URL .themes/THEME_NAME$ rake install['THEME_NAME']$ rake generate 我的博客使用的是whiterspace主题。 ##配置博客 正如Octopress的作者所说的，大部分情况下只需要修改Rakefile和_config.yml就可以了。其中Rakefile是和部署有关的，除非你使用rsync，否则不需要动它。 在_config.yml中，需要对三个部分进行配置。 ###主要配置 1234567891011url: # For rewriting urls for RSS, etctitle: # Used in the header and title tagssubtitle: # A description used in the headerauthor: # Your name, for RSS, Copyright, Metadatasimple_search: # Search engine for simple site searchdescription: # A default meta description for your sitedate_format: # Format dates using Ruby's date strftime syntaxsubscribe_rss: # Url for your blog's feed, defauts to /atom.xmlsubscribe_email: # Url to subscribe by email (service required)category_feeds: # Enable per category RSS feeds (defaults to false in 2.1)email: # Email address for the RSS feed if you want it. ###Jekyll和Plugins 这是和Jekyll和Plugins有关的，详情见Configuring Octopress。 ###第三方组件 这些第三方组件是包含在Octopress中的，只需要配置好就可以添加到自己的博客中。 Github：在sidebar中列出你的Github Repo。 Twitter：添加一个分享到Twitter的按钮。 Google Plus One：设置分享到Google +1。 Pinboard：在sidebar中分享你最近的Pinboard书签。 Delicious：在sidebar中分享你最近的Delicious书签。 Disqus Comments：访问Disqus，创建好账号登录后点击Settings，点击Admin，就可以为个人博客站点创建一个short name，把它添加到_config.yml中的disqus_short_name后面就可以在个人博客中使用Disqus进行评论。 Google Analytics：在Google Analytics中获取跟踪ID，把它添加到_config.yml中的google_analytics_tracking_id后面就可以使用Google Analytics对个人博客进行分析统计。 Facebook：添加Facebooklike按钮。 ##部署博客 ###使用Github User/Organization pages Github的Pages service允许我们为自己的Repo创建展示页面。我们使用http://USER_NAME.github.io作为博客的地址，当然你也可以使用自己的域名（怎么做）。 首先，我们在Github上新建一个Repo，把它命名为USER_NAME.github.io，其中USER_NAME是你在Github上的用户名。这是为了把masterbranch作为web server，使用http://USER_NAME.github.io链接展示你的页面。也就是说你需要在sourcebranch上进行工作，并把生成的内容push到masterbranch上。 如果你觉的这些好麻烦，没事，Octopress会用一个配置task来帮助你把它们做好： 1$ rake setup_github_pages 这个rake task会问你要Github Repo的URL。把上面我们新建的Repo的SSH或者HTTPS URL复制到这里（e.g. git@github.com:USER_NAME/USER_NAME.github.io.git）。 接着，它会为你做以下这些： 存储你的Github Pages仓库URL。 把指向imathis/octopress的remote由origin重命名为octopress。 把你的Github Pages仓库作为默认的originremote。 把activebranch从master切换到source。 使你的博客URL与你的仓库一致。 在_deploy文件夹中设置一个masterbranch用来部署。 紧接着运行： 12$ rake generate$ rake deploy rake generate会把source文件夹下面的markdown文件编译为html文件，并复制到public文件夹下，因此public下的结构跟source的一致，里边的内容为最终的静态页面。 rake deploy会将生成的静态页面复制到_deploy文件夹下并把它们添加到git，commit然后push到Github Pages仓库的masterbranch上。 最后用浏览器打开http://USER_NAME.github.io，你就会看见自己的博客了。首次push可能会花费一段时间等待Github为你生成页面。 当然不要忘记把更改的文件push到sourcebranch上： 123$ git add .$ git commit -m 'YOUR_MESSAGE'$ git push origin source ###使用Github Project pages (gh-pages) Github的Project Pages服务允许你为你的已存在的Repo提供一个站点。它会在你的Repo中寻找gh-pagesbranch，把上面的内容在这个链接中展示http://USER_NAME.github.io/REPO_NAME。 和上面步骤一致，只不过在运行rake setup_github_pages后输入的是已存在Repo的URL。 这个的好处是可以把http://USER_NAME.github.io留下来以后再使用，比如个人主页什么的。 ##开始写博客 ###博客 博客存储在source/_posts文件夹中，并按照Jekyll的惯例进行命名: YYYY-MM-DD-post-title.markdown。文件的名字会被用作URL的一部分，日期会用来对文件进行区分和排序。 Octopress提供一个rake task来生成一篇新的博客： 1$ rake new_post[\"NEW_TITLE\"] 创建好的文件默认是.markdown格式。 用编辑器打开一篇博客，开头的Front Matter会告诉Jekyll如何处理博客和页面。 12345678---layout: posttitle: \"POST_TITLE\"date: POST_DATAcomments: trueexternal-url:categories:--- 你可以关闭评论也可以为博客添加标签。如果还在打草稿，可以添加published: false以免它在生成文件时被发布。你可以添加一个标签也可以添加多个标签： 1234567891011# One categorycategories: Sass# Multiple categories example 1categories: [CSS3, Sass, Media Queries]# Multiple categories example 2categories:- CSS3- Sass- Media Queries ###内容 使用Markdown语法（语法说明）来写博客，也可以使用liquid template features 。 ###生成和预览 123$ rake generate # Generates posts and pages into the public directory$ rake watch # Watches source/ and sass/ for changes and regenerates$ rake preview # Watches, and mounts a webserver at http://localhost:4000 rake preview是一个很好的功能，在发布博客之前可以先预览一下在页面的效果，进行修正。 ##其他好玩的 ###为博客添加返回页面顶部的功能 Scroll To Top这个网站提供了很多返回页面顶部的Widget。 在source/_includes/custom文件夹下新建一个scroll_to_top.html的HTML文件： 1&lt;script type=\"text/javascript\" src=\"http://arrow.scrolltotop.com/YOUR_CHOICE.js\"&gt;&lt;/script&gt; 接着在source/_layouts/default.html中引入该文件： 此时博客在右下角添加了一个返回页面顶部的button。 当然也可以在source/javascripts文件夹下保存使用到的javascript文件，直接在scroll_to_top.html中调用： 1&lt;script type=\"text/javascript\" src=\"/javascripts/FILE_NAME.js\"&gt;&lt;/script&gt; 制作属于自己的button。 ###在首页添加“继续阅读”按钮 在博客中插入&lt;!-- more --&gt;后，在博客首页上，会把该标记之下的博客内容隐藏，点击Read on →按钮可以看到整篇博客。 ###使用个性化的Favicon 在source文件夹下将favicon.png替换成自己的图片。注意，需要使用16px×16px的图片，256色或24位，所以图片的内容不要太复杂。 ##小结 在Github上写博客可以分享知识给其他人，同时也是一个督促自己学习的好方法，毕竟搭建网站需要维护，而Github把这些替你做了，让自己可以专注注意力。当然也请善用，要善对这个平台。 在搭建博客时如果有什么问题可以问我，水平有限，会尽力解答。 参考文献 Octopress 利用Octopress搭建一个Github博客 Blogging With Octopress: Add Comments Octopress添加回到顶部功能 3rd Party Octopress Themes Markdown 语法说明 Octopress 白色主题","categories":[{"name":"Octopress","slug":"Octopress","permalink":"https://near2sea.github.io/categories/Octopress/"}],"tags":[],"keywords":[{"name":"Octopress","slug":"Octopress","permalink":"https://near2sea.github.io/categories/Octopress/"}]}]}